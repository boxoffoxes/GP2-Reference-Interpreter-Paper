\section{The Results}\label{the-results}



\begin{table}[h]
\begin{minipage}{\textwidth}
\centering

\begin{tabular}{llcrrrcrrcrr}
\hline 
&  &~~~~& \multicolumn{3}{c}{Output Graphs} &~~~~& & &~~~~& \multicolumn{2}{c}{Heap/kB}\\
Benchmark          & Host Graph\footnotemark & & Total & Unique   & Failed & & Apps & Time/s   & & Total  & Live \\
\hline 
\input{results_table_all}
\end{tabular}

\caption[Reference interpreter benchmarks]{Reference interpreter benchmark results when generating all possible output graphs}

\label{table:resultsAll}
\footnotetext{For a description of host graphs see \ref{TODO:fixme}}
\end{minipage}
\end{table}




\begin{table}[h]
\begin{minipage}{\textwidth}
\centering

\begin{tabular}{llcrrrcrrcrr}
\hline 
&  &~~~~& \multicolumn{3}{c}{Output Graphs} &~~~~& & &~~~~& \multicolumn{2}{c}{Heap/kB}\\
Benchmark          & Host Graph\footnotemark & & Total & Unique   & Failed & & Apps & Time/s   & & Allocd & Live \\
\hline 
\input{results_table_one}
\end{tabular}

\caption[Reference interpreter benchmarks]{Reference interpreter benchmark results when generating a single output graph}

\label{table:resultsSingle}
\footnotetext{For a description of host graphs see \ref{TODO:fixme}}
\end{minipage}
\end{table}




\subsection{Host Graphs}
\label{subsec:hosts}

Host graphs used for benchmarking are named to give an indication of their overall structure.


\paragraph*{Linear $n$}

A chain of $n$ nodes. The first node has only a single outgoing edge. The last node has only a single incoming edge, and all other nodes have exactly one incoming and one outgoing edge.

\paragraph*{Cyclic $n$}

As Linear $n$, but with an extra edge linking the first and final placed nodes so that every node has exactly one incoming and one outgoing edge.

\paragraph*{$x \times y$ Grid}

A square lattice of $x$ nodes wide by $y$ nodes tall.

\paragraph*{Gen $n$}

The Sierpinski program expects a host graph containing a single node with a numeric label, which is used as the number of iterations of the \texttt{expand!} rule to run.

\paragraph*{$n$ node tri grid}

A triangular lattice of $n$ nodes.


Note that some benchmarks require additional information in a host graph which is not reflected in this naming scheme. For example the grids used in the \textit{Shortest path} benchmark have numeric weights assigned to edges.

In all cases the host graphs used can be found in the GP2 version-control repository.
\footnote{https://github.com/UoYCS-plasma/GP2/tree/master/Haskell/Benchmarks} % TODO: should do a github 'release' and link to that version, so that actual versions of benchmarks and host graphs are preserved.



\subsubsection*{Compilation options}

The interpreter was compiled with GHC version 7.6.3 with optimisations and profiling support enabled, using the following command-line:

\begin{verbatim}
$ ghc -O2 -prof -fprof-auto -rtsopts -o gp2 Main.hs
\end{verbatim}

The profiling information generated by the resulting instrumented binary was used to obtain the numbers presented here, and also to inform the discussion of these results in the next section.

\subsubsection*{Execution environment}

All benchmarking was done on a quad-core Intel i7 clocked at 3.4GHz, with 8GB RAM, running 64-bit Ubuntu 14.04 LTS with kernel 3.13.0.

\subsubsection*{Running GP2}

The \textsc{gp2} executable has three mandatory commandline arguments: a GP2 program, a host graph on which to run the program, and a bound on the number of rule applications.

The rule application bound, $k$ can be used to restrict the size of the search space, only allowing output graphs that can be reached in fewer than $k$ graph transformations. As part of its output, the interpreter reports the number of unfinished computations which halted upon reaching the bound.

% explain commandline options to interpreter (e.g. max apps)

Additionally \textsc{gp2} accepts two optional arguments that control the number of output graphs generated and use of the built-in isomorphism checker:

Passing \texttt{--no-iso} on the commandline disables the isomorphism checker. As this can result in a very large number of output graphs, this flag accepts an optional numeric parameter which sets a maximum number of graphs to generate.

Passing \texttt{--one} is equivalent to \texttt{--no-iso 1}.


Benchmarks were run using the following commandline, with execution time limited to 1 hour. The rule application bound was set sufficiently high that the limit is not reached in any of the benchmarks being run.

\begin{verbatim}
$ timeout --foreground 1h \
      gp2 +RTS -p -sgc.prof -RTS $program $hostGraph 1000000
\end{verbatim}

Unfortunately when the interpreter is killed after exceeding the allowed execution time memory profiling information is not written to disk.



Haskell makes heavy use of recursion, and so its runtime system uses a bounds-checked stack which is by default 8 MB in size, which can be modified by passing appropriate compile- or run-time flags. Several programs consumed all of this stack space and terminated with overflow exceptions, as noted in the table. %TODO note in tables -- is this due to a bug in GraphIsomorphism?



% discuss why some progs overflowed and others didn't.


\subsection{Benchmark performance}

Tables \ref{table:resultsSingle} and \ref{table:resultsAll} summarise the reference interpreter performance for the six benchmark programs, each run on several host graphs. Table \ref{table:resultsAll} shows figures for generating all possible results for each program/host-graph pair, while table \ref{table:resultsSingle} shows results when the interpreter is running in single output graph mode.

