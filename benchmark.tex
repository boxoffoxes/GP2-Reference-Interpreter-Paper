\section{Benchmark Programs}
\label{sec:benchmark}
 
Besides the programs for transitive closure and vertex colouring, we select four more programs for benchmarking.


\subsection{Shortest distances}

\begin{tabular}{lp{10.5cm}}
\ul{Input:} & A graph $G$ with a unique grey node $s$. All edge labels are non-negative integers. \\
\ul{Output:} & The graph obtained from $G$ by marking grey each node reachable from $s$ and replacing its label $l$\/ with $l{:}d$, where $d$\/ is the shortest distance from $s$. (A distance is the sum of the edge labels of a directed path.)
\end{tabular}
  
\begin{figure}[htb]
\begin{center}
\input{Programs/distances.prog}
\end{center}
\caption{Program for shortest distances}\label{fig:shortest-distances}
\end{figure}

\ul{Notes}
\begin{enumerate}
\setlength{\itemsep}{-.5ex}
\item The result is unique up to isomorphism.
\item The input requirement can be relaxed by allowing negative edge labels but forbidding directed cycles with a negative distance.
\end{enumerate}


\subsection{Recognising acyclic graphs}
\label{sec:acyclic}

\begin{tabular}{lp{10.5cm}}
\ul{Input:} & Any graph $G$. \\
\ul{Output:} & Graph $G$ if it is acyclic, otherwise the program fails.
\end{tabular}
  
\begin{figure}[htb]
\begin{center}
\input{Programs/acyclic.prog}
\end{center}
\caption{Program for checking acyclicity}\label{fig:acyclicity}
\end{figure}

% \subsection{Rooted 2-colouring}
% 
% \begin{tabular}{lp{10.5cm}}
% \ul{Input:} & A connected graph $G$. \\
% \ul{Output:} & If $G$\/ is 2-colourable, then the output is obtained from $G$\% / by marking each node with either red or blue. The source and target of each % non-loop edge have different colours.\\
% & If $G$\/ is not 2-colourable, then the output is $G$.
% \end{tabular}
% 
% \vspace{10pt}
% \input{Programs/rooted-2colouring} \\
% \vspace{10pt}
% 
% \ul{Notes}
% \begin{enumerate}
% \setlength{\itemsep}{-.5ex}
% \item The nodes in rule \ttt{unroot} are violet. They can match a node of any % colour. A violet right-hand node takes the colour of the match of the left-han% d node.
% \item The edges in the \ttt{mark}, \ttt{joined} and \ttt{back} rules are \emph% {bidirectional}. They match host graph edges in either direction.
% \end{enumerate}


\subsection{Generating Sierpinski triangles}

\begin{tabular}{lp{10.5cm}}
\ul{Input:} & A single node labelled with a non-negative integer $n$. \\
\ul{Output:} & The Sierpinski triangle of generation $n$.
\end{tabular}
  
\begin{figure}[p]
\begin{center}
\input{Programs/sierpinski.prog}
\end{center}
\caption{Program for generating Sierpinski triangles}\label{fig:Sierpinski-program}
 \begin{center}
  \includegraphics[scale=.35,angle=-15]{sierpinski-3.eps}
 \end{center}
\vspace*{-2.5cm}
\caption{Third generation Sierpinski triangle \label{fig:sierpinski}}
\end{figure}

\ul{Notes}
\begin{enumerate}
\setlength{\itemsep}{-.5ex}
\item The next page shows an example of a Sierpinski triangle.
\item The derivation length and the output size are exponential in $n$.
\end{enumerate}

Sierpinski triangles pose a hard challenge for graph transformation: generating the $n$-th triangle requires space and a number of rule applications exponential in $n$. This problem was part of the 2007 tool contest for graph transformation, where the goal was to generate triangles of generation numbers as high as possible and as fast as possible \cite{Taentzer_et_al08a}.
