
\section{The implementation}


\subsection{Data structures}

The reference interpreter uses a trivial implementation of an extensible array library, written initially without concern for performance issues, but encapsulated in such a way as to be replaceable with a more efficient library later if required. Specifically, a graph is represented as a pair of extensible arrays: one for the nodes and one for the edges.

\subsection{Program environment}

\subsection{Graph matching}

The graph matcher constructs a list of GraphMorphisms, where a GraphMorphism is a data structure containing the program environment, namely the variable-value assignments; a mapping between the NodeIds in the LHS of the rule graph and the corresponding NodeIds in the host graph; and a similar list of EdgeId mappings. Morphisms are generated by first constructing the set of all possible NodeMorphisms, then augmenting each node morphism with appropriate edge mappings. A NodeMorphism is a GraphMorphism without a list of EdgeId mappings.


The node matching algorithm takes as input the LHS L and the host graph G. It works as follows:

\begin{enumerate}
	\item Count the number of nodes k in L.
	\item Generate all sets of size k containing nodes from G.
	\item Iterate through the sets from step 2, comparing node labels in L to labels in G. Keep the sets in which node labels correspond for all pairs of nodes.
\end{enumerate}

It is clear that the complexity of this algorithm increases rapidly with both the size of L and the size of G. This is a naive matching strategy that would not be appropriate if performance were a consideration. In this case, where correctness is a greater concern, the simplicity of this algorithm is of benefit by making the source code easier to reason about.


The edge-matching algorithm takes as input the LHS L, the host graph G and a node morphisms NM. It works as follows:


\begin{enumerate}
	\item Get the source and target of each edge in L.
	\item Using NM, translate each source and target pair to the corresponding pair of host graph nodes.
	\item For each pair of host graph nodes (source, target), get the set of edges in G from source to target.
	\item Associate each edge in L with its set of candidate edge matches found in step 3.
	\item For all edges in L, test their label against the labels of each of its candidate matches. If the host label matches the LHS label (possibly with a variable-value assignment), add the assignment to the environment and add the edge match to the morphism. Otherwise, do nothing.
\end{enumerate}


Since it only generates edge sets that conform to the structural requirements of a graph morphism, it is more sophisticated than the node matching algorithm. The edge-matching algorithm has a smooth implementation due to features of Haskell. The first four steps are achieved with maps, ensuring that each LHS-edge is paired up with the correct set of host-edges.


\subsection{The dangling condition}

In the double-pushout framework of graph transformation, on which GP 2 is based, a rule may not be applicable for a particular match as applying the rule could leave an edge without a source or target. The dangling condition forbids this: it requires that all host edges not deleted by the rule are not incident to nodes deleted by the role.


\subsection{Isomorphism checking}

Producing all possible output graphs leads to the issue that many of the results may be isomorphic. To simplify analysis of the results, we implemented a basic isomorphism checker, so that our program completes with a set of all possible distinct output graphs, plus a count of the number of isomorphic variants of each graph that were seen.


\subsection{Rooted graphs}

Lessons learned from the implementation of the original GP language led to the addition of support for root nodes to GP2. A node carries a simple binary flag indicating whether it is a root node or not. A root node in a rule graph can only match a root node in the host graph, and then only if all other normal matching conditions are met, eliminating a large number of possible subgraph matches with only an inexpensive boolean test. Whereas a non-root node in the rule graph may match a node irrespective of its root-node status.


Even in the reference interpreter, addition of a root node can result in a significant performance gain of TODO.

