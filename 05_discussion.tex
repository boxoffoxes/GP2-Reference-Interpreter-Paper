\section{Related and Future Work}
\label{sec:relatedandfuture}

Languages based on graph transformation rules include
%Fujaba?
\textsc{Progres} \cite{Schuerr-Winter-Zuendorf99a},
\textsc{Agg} \cite{Ermel-Rudolf-Taentzer99a,Runge-Ermel-Taentzer11a},
\textsc{Gamma} \cite{Fradet-LeMetayer98a},
\textsc{Groove} \cite{Ghamarian-deMol-Rensink-Zambon-Zimakova12a},
\textsc{GrGen.Net} \cite{Jakumeit-Buchwald-Kroll10a} and
\textsc{Porgy} \cite{Fernandez-Kirchner-Mackie-Pinaud14a}.
To our knowledge, these languages do not have (published) implementations in the same spirit as our reference interpreter. For example, \textsc{Groove} and \textsc{GrGen.Net} are two of the most widely used systems. The Java source code for the \textsc{Groove} implementation, including a graphical development suite, extends to around 150,000 lines. \textsc{GrGen.Net} is implemented in a combination of Java and C\#. A Java front-end is used to generate C\# code and .NET assemblies from a textual specification of a \textsc{GrGen} program. The run-time system and other components are written in C\#. In all there are around 68,000 lines of Java source for the front-end, and around 93,000 lines of C\# for the run-time system, API support and an interactive shell.

We recognise that both \textsc{Groove} and \textsc{GrGen.Net} are mature and fully-featured systems, and \textsc{GrGen.Net} in particular is highly optimising. Even so, the contrast with the 1000-line Haskell sources for our GP 2 reference interpreter is striking.

\section{Conclusions}
\label{sec:conclusions}

%\subsection{Contributions}

%This work lays a valuable foundation for checking the correctness of subsequent GP2 interpreters and compilers. It also demonstrates the use of a lazy functional language to implement a nondeterministic language. Perhaps the data from running the interpreter on our test programs may reveal some insights into properties/features of the interpreter.




