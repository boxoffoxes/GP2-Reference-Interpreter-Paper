\section{Related and Future Work}
\label{sec:relatedandfuture}
Early programming languages were often defined by their implementations,
perhaps in the form of a \emph{definitional interpreter}.
We now more abstract techniques for defining operational semantics.
However, in recent years there has been a 
rehabilitation of interpreters as executable counterparts to semantic
definitions --- eg. \cite{Campbell2012}. 
Motivation varies, but here's an extract from the preface
of an influential textbook: 
\begin{quote}
\textit{Our goal is to provide a deep, working understanding of the essential concepts of programming languages. \ldots
Most of these essentials relate to the semantics, or meaning, of program elements. Such meanings reflect how program elements are interpreted as the program executes. \ldots
% Programs called interpreters provide the most direct, executable expression of program semantics. \ldots
% We therefore choose interpreters as our primary vehicle for expressing the semantics of programming language elements. \ldots
The most interesting question about a program as object is, \textnormal{``What does it do?''} The study of interpreters tells us this. Interpreters are critical because they reveal nuances of meaning, and are the direct path to more efficient compilation and to other kinds of program analyses.} \cite{Friedmanetal2008}
\end{quote}
In several respects, our motivation is similar.
We adopt the slogan: \emph{Semantics first!}.
But then, following the semantic definition, we write a reference interpreter in order to
promote a ``\textit{deep, working understanding}'' of the GP 2 design,
and to find ``\textit{path(s) to more efficient compilation \ldots and program analysis}''.

Languages based on graph-transformation rules include
%Fujaba?
\textsc{Progres} \cite{Schuerr-Winter-Zuendorf99a},
\textsc{Agg} \cite{Ermel-Rudolf-Taentzer99a,Runge-Ermel-Taentzer11a},
\textsc{Gamma} \cite{Fradet-LeMetayer98a},
\textsc{Groove} \cite{Ghamarian-deMol-Rensink-Zambon-Zimakova12a},
\textsc{GrGen.Net} \cite{Jakumeit-Buchwald-Kroll10a} and
\textsc{Porgy} \cite{Fernandez-Kirchner-Mackie-Pinaud14a}.
To our knowledge, none of these languages has a published implementation in the same spirit as our reference interpreter. For example, \textsc{Groove} and \textsc{GrGen.Net} are two of the most widely used systems. The Java source code for the \textsc{Groove} implementation, including a graphical development suite, extends to around 150,000 lines. \textsc{GrGen.Net} is implemented in a combination of Java and C\#: a Java front-end is used to generate C\# code and .NET assemblies from a textual specification of a \textsc{GrGen} program; the run-time system and other components are written in C\#. In all there are around 68,000 lines of Java source for the front-end, and around 93,000 lines of C\# for the run-time system, API support and an interactive shell.
We recognise that both \textsc{Groove} and \textsc{GrGen.Net} are mature and fully-featured systems, and \textsc{GrGen.Net} in particular is highly optimising. Even so, the contrast with the 1000-line Haskell sources for our GP 2 reference interpreter is striking.

We have begun work on two compiled implementations of GP2. One generates code for an abstract machine; the other translates GP~2 programs to C. They also differ in the way the graph data structure is accessed and the strategies employed to match left-hand sides of rules. The reference interpreter is supporting these ongoing developments. For example, some front-end components are re-used, and we check output graphs against isomorphism classes
computed by the interpreter.


\section{Conclusions}
\label{sec:conclusions}

% Claims for reference interpreter largely realised
% Emphasise  concise implementation of labelled graph transformation PL with non-determinism, backtracking etc.
% Common choice of implementation language: C#, Java -- some merits of Haskell.

We feel that our original aims in producing a reference interpreter have been largely realised. We have a compact implementation of GP~2 which we can use as a tool for testing programs and researching future graph language compilers, and have demonstrated the merits of a lazy functional language in the implementation of a non-deterministic graph programming language.

% Another benefit: review corner-cases of semantics in light of example applications
In the process we have reviewed corner-cases of the operational semantics in light of the example applications we have developed.

% Main reservation: all results, scale

Our main reservation is in handling of all results mode, where complex problems result in long execution times and significant memory usage. Nevertheless, we view leaving a computation to run for several days on a powerful machine to produce a set of all possible output graphs as an acceptable one-time cost in the context of testing a subsequent GP~2 compiler. 




