\section{Related and Future Work}
\label{sec:relatedandfuture}
Early programming languages were often defined by their implementations,
perhaps in the form of a \emph{definitional interpreter}.
We now more abstract techniques for defining operational semantics.
However, in recent years there has been a 
rehabilitation of interpreters as executable counterparts to semantic
definitions --- eg. \cite{Campbell2012}. 
Motivation varies, but here's an extract from the preface
of an influential textbook: 
\begin{quote}
\textit{Our goal is to provide a deep, working understanding of the essential concepts of programming languages. \ldots
Most of these essentials relate to the semantics, or meaning, of program elements. Such meanings reflect how program elements are interpreted as the program executes. \ldots
% Programs called interpreters provide the most direct, executable expression of program semantics. \ldots
% We therefore choose interpreters as our primary vehicle for expressing the semantics of programming language elements. \ldots
The most interesting question about a program as object is, \textnormal{``What does it do?''} The study of interpreters tells us this. Interpreters are critical because they reveal nuances of meaning, and are the direct path to more efficient compilation and to other kinds of program analyses.} \cite{Friedmanetal2008}
\end{quote}
In several respects, our motivation is similar.
We adopt the slogan: \emph{Semantics first!}.
But then, following the semantic definition, we write a reference interpreter in order to
promote a ``\textit{deep, working understanding}'' of the GP 2 design,
and to find ``\textit{path(s) to more efficient compilation \ldots and program analysis}''.

Languages based on graph-transformation rules include
%Fujaba?
\textsc{Progres} \cite{Schuerr-Winter-Zuendorf99a},
\textsc{Agg} \cite{Ermel-Rudolf-Taentzer99a,Runge-Ermel-Taentzer11a},
\textsc{Gamma} \cite{Fradet-LeMetayer98a},
\textsc{Groove} \cite{Ghamarian-deMol-Rensink-Zambon-Zimakova12a},
\textsc{GrGen.Net} \cite{Jakumeit-Buchwald-Kroll10a} and
\textsc{Porgy} \cite{Fernandez-Kirchner-Mackie-Pinaud14a}.
To our knowledge, none of these languages has a published implementation in the same spirit as our reference interpreter. For example, \textsc{Groove} and \textsc{GrGen.Net} are two of the most widely used systems. The Java source code for the \textsc{Groove} implementation, including a graphical development suite, extends to around 150,000 lines. \textsc{GrGen.Net} is implemented in a combination of Java and C\#: a Java front-end is used to generate C\# code and .NET assemblies from a textual specification of a \textsc{GrGen} program; the run-time system and other components are written in C\#. In all there are around 68,000 lines of Java source for the front-end, and around 93,000 lines of C\# for the run-time system, API support and an interactive shell.
We recognise that both \textsc{Groove} and \textsc{GrGen.Net} are mature and fully-featured systems, and \textsc{GrGen.Net} in particular is highly optimising. Even so, the contrast with the 1000-line Haskell sources for our GP 2 reference interpreter is striking.

We have begun work on two compiled implementations of GP2. One generates code for an abstract machine; the other translates GP~2 programs to C. They also differ in the way the graph data structure is accessed and the strategies employed to match left-hand sides of rules. The reference interpreter is supporting these ongoing developments. For example, some front-end components are re-used, and we check output graphs against isomorphism classes
computed by the interpreter.
\section{Conclusions}
\label{sec:conclusions}

%\subsection{Contributions}

%This work lays a valuable foundation for checking the correctness of subsequent GP2 interpreters and compilers. It also demonstrates the use of a lazy functional language to implement a nondeterministic language. Perhaps the data from running the interpreter on our test programs may reveal some insights into properties/features of the interpreter.




