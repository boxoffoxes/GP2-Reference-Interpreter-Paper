
\section{Discussion}

%It is clear from tables \ref{table:resultsSingle} and \ref{table:resultsAll} that our interpreter is in no way competitive with 



% Generating all possible intermediate graphs

\subsubsection*{Exhaustive search}

When viewing the results in \ref{table:resultsAll}, it should be remembered that the interpreter is computing \textit{all possible} output graphs for a given program/host-graph pair, then consolidating the results based on isomorphism. It is therefore unsurprising that execution time increases exponentially with increasing size of host graph.

However, as already mentioned, more consideration was given to code-correctness and readability than to execution speed or memory consumption.

, and while performance is acceptable for some quite complex programs, it is nevertheless easy to find cases in which performance degrades to an unacceptable degree. A particular example being the Sierpinski triangle benchmark program, which exhibits exponential growth in the number of possible intermediate graphs, and has an execution time in excess of two weeks after only three generations of expansion!

Comparing tables \ref{table:resultsAll} and \ref{table:resultsSingle} gives an indication of the additional costs associated with generating all graphs and isomorphism-checking the results.

One of the most serious limits on the performance of the reference interpreter, which impacts matching of any non-trivial rule, is the naive node-matching strategy. Given a rule with $n$ nodes, select all permutations of $n$ nodes from the host graph, then discard those that fail to meet rootedness, label and edge constraints.

While from the point of view of simplicity this is a reasonable choice for finding all possible outputs for each rule, it is a seriously sub-optimal way of finding a single output graph; for any non-trivial rule and host pair the chances of $n$ nodes selected essentially at random matching a rule is very low, meaning that many permutations need to be inspected for each successful match.

That this strategy is repeated for all of the intermediate graphs generated by the previous rule application explains the combinatorial explosions we see in heavily non-deterministic programs like \textit{Sierpinski} and \textit{Shortest path}.

% interpreter cost vs compiler
\subsubsection*{Interpreter costs}

Any interpreter has run-time costs which would be paid at compile-time in a compiler. These costs can account for a significant percentage of the execution time.

In the sub-second execution time benchmarks, profiling information indicated that a significant portion of the execution time was spent parsing the rule-graphs and building map structures.




\subsubsection*{Generic data structures}

The current version of the interpreter uses a generic lazy map data structure which gives a reasonable balance between cost of search and cost of update. 

% mention performance of graph data structure


The first prototypes of the interpreter stored the graphs as linked-lists of key/value pairs. The result was an interpreter which spent most of its execution time traversing these lists retrieving nodes and edges. Switching to the faster map structure yielded a factor of two speed improvement.

Nevertheless, a single function, \texttt{idLookup} which fetches a node or edge by its unique identifier, still typically accounts for up to 35 percent of our total execution time in several of the listed benchmarks.

An underlying data structure tuned to our specific usage patterns, and judiciously indexed could dramatically reduce this high cost of node and edge retrieval.


% Another significant cost is isomorphism checking. 
\subsubsection*{Isomorphism checking}

Another cost associated with generating all possible output graphs is isomorphism checking. In benchmarks where nondeterminism gives us multiple ways of reaching similar output graphs we want a way of reducing this potentially large set of outputs to those which are truly distinct. A particularly extreme example of this can be seen in the \textit{6 node tri-grid} host graph of the \textit{Shortest paths} benchmark. Here we produced nearly 22~000 isomorphic output graphs.


% Cost of profiling
\subsubsection*{Profiling costs}

We have also incurred some incidental costs by gathering the profiling information used to generate 

% TODO: guestimate profiling costs


% TODO: fail early and fail cheaply!

%\subsection{Contributions}

%This work lays a valuable foundation for checking the correctness of subsequent GP2 interpreters and compilers. It also demonstrates the use of a lazy functional language to implement a nondeterministic language. Perhaps the data from running the interpreter on our test programs may reveal some insights into properties/features of the interpreter.




